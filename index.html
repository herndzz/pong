<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pong Game Avan√ßado</title>
    <style>
        /* Estilos globais do corpo da p√°gina */
        body {
            text-align: center;
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            transition: background-color 0.3s ease, color 0.3s ease;
            user-select: none; /* Evita sele√ß√£o de texto durante o jogo */
        }
        body.dark-theme {
            background-color: #1a1a1a;
            color: #ffffff;
        }
        body.light-theme {
            background-color: #ffffff;
            color: #000000;
        }
        canvas {
            border: 1px solid;
            display: block;
            margin: 20px auto;
            touch-action: none;
        }
        .dark-theme canvas {
            background-color: #2a2a2a;
            border-color: #ffffff;
        }
        .light-theme canvas {
            background-color: #f0f0f0;
            border-color: #000000;
        }
        #gameIntro, #gameMenu, #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            border-radius: 10px;
            max-width: 500px;
        }
        .dark-theme #gameIntro, .dark-theme #gameMenu, .dark-theme #gameOver {
            background: rgba(0, 0, 0, 0.9);
            color: #ffffff;
        }
        .light-theme #gameIntro, .light-theme #gameMenu, .light-theme #gameOver {
            background: rgba(255, 255, 255, 0.9);
            color: #000000;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
            border-radius: 5px;
        }
        .dark-theme button {
            background-color: #444;
            color: #fff;
            border: 1px solid #fff;
        }
        .light-theme button {
            background-color: #ddd;
            color: #000;
            border: 1px solid #000;
        }
        #achievementsList {
            text-align: left;
            margin-top: 20px;
        }
        #achievementsList li.locked {
            color: gray;
        }
        #notification {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px;
            border-radius: 5px;
        }
        .dark-theme #notification {
            background: rgba(0, 0, 0, 0.7);
            color: #ffffff;
        }
        .light-theme #notification {
            background: rgba(255, 255, 255, 0.7);
            color: #000000;
        }
    </style>
</head>
<body class="dark-theme">
    <h1>Pong Game Avan√ßado</h1>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    <p>Pontua√ß√£o: <span id="score">0</span> | N√≠vel: <span id="level">1</span> | Maior Pontua√ß√£o: <span id="highScore">0</span></p>
    <div id="notification"></div>
    <div id="gameIntro">
        <h2>üèì Bem-vindo ao Pong Avan√ßado! üèì</h2>
        <p><strong>Regras do Jogo:</strong></p>
        <ul>
            <li>üéÆ Use as setas ‚Üë‚Üì (ou toque/arraste em dispositivos m√≥veis) para mover sua raquete (esquerda)</li>
            <li>üéØ Rebata a bola contra a raquete da IA (direita) para marcar pontos</li>
            <li>üìà A cada 5 pontos, o n√≠vel aumenta, tornando o jogo mais desafiador</li>
            <li>ÔøΩ Ganhe pontos rebatendo a bola com precis√£o</li>
            <li>üèÜ Conquistas s√£o desbloqueadas ao atingir objetivos especiais</li>
            <li>‚ö†Ô∏è O jogo termina se a bola passar pela sua raquete</li>
            <li>‚è∏Ô∏è Pressione P para pausar, M para alternar som, ESC para menu</li>
        </ul>
        <button onclick="game.showMenu()">üöÄ Continuar</button>
    </div>
    <div id="gameMenu">
        <h2>Menu</h2>
        <div style="margin: 20px 0;">
            <h3>Dificuldade</h3>
            <button onclick="game.setDifficulty('easy'); game.start()">üü¢ F√°cil</button>
            <button onclick="game.setDifficulty('medium'); game.start()">üü° M√©dio</button>
            <button onclick="game.setDifficulty('hard'); game.start()">üî¥ Dif√≠cil</button>
        </div>
        
        <div style="margin: 20px 0;">
            <h3>Configura√ß√µes</h3>
            <button onclick="game.toggleTheme()">üé® Alternar Tema</button>
            <button onclick="game.audioManager.enabled = !game.audioManager.enabled; game.audioManager.toggle(); this.textContent = game.audioManager.enabled ? 'üîä Som: ON' : 'üîá Som: OFF'">
                üîä Som: ON
            </button>
            <button onclick="game.adaptiveDifficulty = !game.adaptiveDifficulty; StorageManager.set('adaptiveDifficulty', game.adaptiveDifficulty); this.textContent = game.adaptiveDifficulty ? 'ü§ñ IA Adaptativa: ON' : 'ü§ñ IA Adaptativa: OFF'">
                ü§ñ IA Adaptativa: ON
            </button>
        </div>
        
        <div style="margin: 20px 0;">
            <h3>Estat√≠sticas</h3>
            <p>Total de Jogos: <span id="totalGames">0</span></p>
            <p>Recorde de Combo: <span id="maxComboDisplay">0</span></p>
            <button onclick="if(confirm('Tem certeza que deseja resetar todas as estat√≠sticas?')) { StorageManager.clear(); location.reload(); }">
                üóëÔ∏è Resetar Estat√≠sticas
            </button>
        </div>
        
        <div id="achievementsList"></div>
        
        <div style="margin-top: 20px;">
            <h3>Controles</h3>
            <p><strong>Teclado:</strong> ‚Üë‚Üì para mover, P para pausar, M para som, ESC para menu</p>
            <p><strong>Mobile:</strong> Toque e arraste, toque duplo para pausar</p>
        </div>
    </div>
    <div id="gameOver">
        <h2>Game Over</h2>
        <div style="margin: 20px 0;">
            <p><strong>Pontua√ß√£o Final:</strong> <span id="finalScore">0</span></p>
            <p><strong>N√≠vel Alcan√ßado:</strong> <span id="finalLevel">1</span></p>
            <p><strong>Tempo de Jogo:</strong> <span id="finalTime">0</span>s</p>
            <p><strong>Max Combo:</strong> <span id="finalCombo">0</span></p>
            <p><strong>Velocidade M√°xima:</strong> <span id="finalMaxSpeed">0</span></p>
        </div>
        
        <div style="margin: 20px 0;">
            <button onclick="game.start()">üîÑ Jogar Novamente</button>
            <button onclick="game.showMenu()">üìã Voltar ao Menu</button>
        </div>
        
        <div id="newRecordNotification" style="display: none; color: gold; font-weight: bold; margin: 10px 0;">
            üéâ NOVO RECORDE! üéâ
        </div>
    </div>

<script>
// ================== CONFIGURA√á√ïES E CONSTANTES ==================
const CONFIG = {
    CANVAS: {
        WIDTH: 800,
        HEIGHT: 400
    },
    FPS: 60,
    PADDLE: {
        WIDTH: 10,
        HEIGHT: 100,
        SPEED: 8
    },
    BALL: {
        SIZE: 10,
        DEFAULT_SPEED_X: 5,
        DEFAULT_SPEED_Y: 3,
        MAX_SPEED: 20
    },
    PARTICLE: {
        LIFETIME: 30,
        COUNT_ON_HIT: 5
    },
    COMBO: {
        RESET_TIME: 180, // 3 segundos a 60fps
        MIN_FOR_NOTIFICATION: 5
    },
    LEVEL: {
        POINTS_PER_LEVEL: 5,
        DIFFICULTY_FACTOR: 0.1
    }
};



const SOUND_FREQUENCIES = {
    HIT: 440,
    SCORE: 880,
    GAMEOVER: 220,
    COMBO: 1200,
    ACHIEVEMENT: 660,
    DEFAULT: 660
};

// ================== CLASSES UTILIT√ÅRIAS ==================

/**
 * Classe para gerenciar configura√ß√µes e persist√™ncia de dados
 */
class StorageManager {
    static get(key, defaultValue = null) {
        const value = localStorage.getItem(key);
        return value !== null ? JSON.parse(value) : defaultValue;
    }

    static set(key, value) {
        localStorage.setItem(key, JSON.stringify(value));
    }

    static clear() {
        localStorage.clear();
    }
}

/**
 * Classe para gerenciar √°udio do jogo
 */
class AudioManager {
    constructor() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = StorageManager.get('soundEnabled', true);
    }

    playSound(type) {
        if (!this.enabled) return;
        
        try {
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            oscillator.type = 'sine';
            
            const frequency = SOUND_FREQUENCIES[type.toUpperCase()] || SOUND_FREQUENCIES.DEFAULT;
            oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
            
            if (type === 'achievement') {
                oscillator.frequency.exponentialRampToValueAtTime(880, this.audioContext.currentTime + 0.2);
            }
            
            gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.5);
            
            oscillator.start();
            oscillator.stop(this.audioContext.currentTime + 0.5);
        } catch (error) {
            console.warn('Erro ao reproduzir som:', error);
        }
    }

    toggle() {
        this.enabled = !this.enabled;
        StorageManager.set('soundEnabled', this.enabled);
        return this.enabled;
    }
}

/**
 * Classe que representa uma conquista no jogo
 */
class Achievement {
    constructor(id, name, description, condition) {
        this.id = id;
        this.name = name;
        this.description = description;
        this.condition = condition;
        this.unlocked = false;
    }
}

/**
 * Classe que gerencia conquistas do jogo
 */
class AchievementManager {
    constructor() {
        this.achievements = this.initializeAchievements();
        this.loadAchievements();
    }

    initializeAchievements() {
        return [
            new Achievement('score10', 'Pontuador Iniciante', 'Marque 10 pontos em uma partida', (game) => game.score >= 10),
            new Achievement('score25', 'Pontuador Intermedi√°rio', 'Marque 25 pontos em uma partida', (game) => game.score >= 25),
            new Achievement('score50', 'Pontuador Avan√ßado', 'Marque 50 pontos em uma partida', (game) => game.score >= 50),
            new Achievement('score100', 'Mestre dos Pontos', 'Marque 100 pontos em uma partida', (game) => game.score >= 100),
            new Achievement('level3', 'Mestre de N√≠veis', 'Alcance o n√≠vel 3', (game) => game.level >= 3),
            new Achievement('level5', 'Veterano', 'Alcance o n√≠vel 5', (game) => game.level >= 5),
            new Achievement('level10', 'Lenda', 'Alcance o n√≠vel 10', (game) => game.level >= 10),
            new Achievement('speedDemon', 'Dem√¥nio da Velocidade', 'Alcan√ßar velocidade m√°xima da bola', (game) => game.ball && Math.abs(game.ball.speedX) > 15),
            new Achievement('survivor', 'Sobrevivente', 'Jogar por mais de 2 minutos', (game) => game.gameTime >= 120000),
            new Achievement('perfectStart', 'In√≠cio Perfeito', 'Marcar 5 pontos seguidos no in√≠cio', (game) => game.consecutiveHits >= 5 && game.score === game.consecutiveHits)
        ];
    }

    loadAchievements() {
        const saved = StorageManager.get('achievements', []);
        this.achievements.forEach(ach => {
            ach.unlocked = saved.includes(ach.id);
        });
    }

    saveAchievements() {
        const unlockedIds = this.achievements.filter(ach => ach.unlocked).map(ach => ach.id);
        StorageManager.set('achievements', unlockedIds);
    }

    checkAchievements(game) {
        this.achievements.forEach(ach => {
            if (!ach.unlocked && ach.condition(game)) {
                ach.unlocked = true;
                game.showNotification(`üèÜ Conquista Desbloqueada: ${ach.name}`);
                game.audioManager.playSound('achievement');
                this.saveAchievements();
            }
        });
    }

    updateDisplay(element) {
        element.innerHTML = '<h3>Conquistas</h3><ul>' +
            this.achievements.map(ach => 
                `<li class="${ach.unlocked ? 'unlocked' : 'locked'}">${ach.name}: ${ach.description}</li>`
            ).join('') + '</ul>';
    }
}

/**
 * Classe que representa as part√≠culas visuais do jogo
 */
class Particle {
    constructor(x, y, ballSpeedX, ballSpeedY) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4 + ballSpeedX * 0.3;
        this.vy = (Math.random() - 0.5) * 4 + ballSpeedY * 0.3;
        this.life = CONFIG.PARTICLE.LIFETIME;
        this.maxLife = CONFIG.PARTICLE.LIFETIME;
        this.size = Math.random() * 3 + 5;
        this.initialSize = this.size;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        
        const lifeRatio = this.life / this.maxLife;
        this.size = this.initialSize * lifeRatio;
        
        return this.life > 0;
    }

    draw(ctx, theme) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        const alpha = this.life / this.maxLife;
        ctx.fillStyle = theme === 'dark' 
            ? `rgba(255, 165, 0, ${alpha})` 
            : `rgba(255, 69, 0, ${alpha})`;
        ctx.fill();
        ctx.closePath();
    }
}

/**
 * Classe que representa as raquetes (paddles) do jogo
 */
class Paddle {
    constructor(x, y, isAI = false) {
        this.x = x;
        this.y = y;
        this.width = CONFIG.PADDLE.WIDTH;
        this.height = CONFIG.PADDLE.HEIGHT;
        this.speed = CONFIG.PADDLE.SPEED;
        this.isAI = isAI;
        this.defaultHeight = CONFIG.PADDLE.HEIGHT;
        this.defaultSpeed = CONFIG.PADDLE.SPEED;
    }

    moveAI(ballY, canvasHeight) {
        if (!this.isAI) return;
        
        const center = this.y + this.height / 2;
        const errorMargin = this.height * 0.2;
        
        if (center < ballY - errorMargin) {
            this.y += this.speed * 0.7;
        }
        if (center > ballY + errorMargin) {
            this.y -= this.speed * 0.7;
        }
        
        this.y = Math.max(0, Math.min(this.y, canvasHeight - this.height));
    }

    moveUp() {
        this.y = Math.max(0, this.y - this.speed);
    }

    moveDown(canvasHeight) {
        this.y = Math.min(canvasHeight - this.height, this.y + this.speed);
    }

    reset() {
        this.height = this.defaultHeight;
        this.speed = this.defaultSpeed;
    }

    draw(ctx, theme) {
        ctx.fillStyle = theme === 'dark' ? '#ffffff' : '#000000';
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
}

/**
 * Classe que representa a bola do jogo
 */
class Ball {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = CONFIG.BALL.SIZE;
        this.speedX = CONFIG.BALL.DEFAULT_SPEED_X;
        this.speedY = CONFIG.BALL.DEFAULT_SPEED_Y;
        this.trail = [];
        this.defaultSpeedX = CONFIG.BALL.DEFAULT_SPEED_X;
        this.defaultSpeedY = CONFIG.BALL.DEFAULT_SPEED_Y;
    }

    update(canvas, paddle1, paddle2, scoreCallback, game) {
        this.x += this.speedX;
        this.y += this.speedY;
        
        this.updateTrail();
        
        // Verifica colis√£o com paredes (sempre continua o jogo)
        this.checkWallCollision(canvas, game);
        
        // Verifica colis√£o com raquetes (sempre continua o jogo)
        this.checkPaddleCollision(canvas, paddle1, paddle2, scoreCallback, game);
        
        // Verifica se o jogo deve terminar (pode retornar false para game over)
        return this.checkGameEnd(canvas, paddle1, paddle2, game);
    }

    updateTrail() {
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 15) this.trail.shift();
    }

    checkWallCollision(canvas, game) {
        if (this.y <= 0 || this.y >= canvas.height - this.size) {
            this.speedY = -this.speedY;
            game.audioManager.playSound('hit');
            this.createParticles(game);
        }
    }

    checkPaddleCollision(canvas, paddle1, paddle2, scoreCallback, game) {
        // Colis√£o com paddle do jogador
        if (this.x <= paddle1.x + paddle1.width && 
            this.x + this.size >= paddle1.x &&
            this.y + this.size >= paddle1.y && 
            this.y <= paddle1.y + paddle1.height &&
            this.speedX < 0) { // S√≥ colide se estiver indo em dire√ß√£o ao paddle
            
            this.handlePaddleHit(paddle1, scoreCallback, game, true);
        }
        
        // Colis√£o com paddle da IA
        else if (this.x + this.size >= paddle2.x && 
                 this.x <= paddle2.x + paddle2.width &&
                 this.y + this.size >= paddle2.y && 
                 this.y <= paddle2.y + paddle2.height &&
                 this.speedX > 0) { // S√≥ colide se estiver indo em dire√ß√£o ao paddle
            
            this.handlePaddleHit(paddle2, null, game, false);
        }
    }

    handlePaddleHit(paddle, scoreCallback, game, isPlayer) {
        const hitPoint = (this.y - (paddle.y + paddle.height / 2)) / (paddle.height / 2);
        
        if (isPlayer) {
            this.speedX = Math.abs(this.speedX) * 1.05;
            this.x = paddle.x + paddle.width + 2; // Reposiciona para evitar m√∫ltiplas colis√µes
            scoreCallback();
            game.playerHits++;
        } else {
            this.speedX = -Math.abs(this.speedX) * 1.05;
            this.x = paddle.x - this.size - 2; // Reposiciona para evitar m√∫ltiplas colis√µes
            game.aiHits++;
        }
        
        this.speedY = hitPoint * 6;
        
        // Limita velocidade
        this.speedX = Math.max(-CONFIG.BALL.MAX_SPEED, Math.min(CONFIG.BALL.MAX_SPEED, this.speedX));
        this.speedY = Math.max(-15, Math.min(15, this.speedY));
        
        game.audioManager.playSound('hit');
        game.ballHits++;
        this.createParticles(game);
    }

    checkGameEnd(canvas, paddle1, paddle2, game) {
        // Verifica se a bola saiu pela esquerda (lado do jogador)
        if (this.x + this.size < 0) {
            // Verifica se a bola passou pela altura da raquete
            if (this.y + this.size < paddle1.y || this.y > paddle1.y + paddle1.height) {
                // Bola passou longe da raquete - JOGADOR PERDE
                return false; // Game over
            }
        }
        
        // Verifica se a bola saiu pela direita (lado da IA)
        else if (this.x > canvas.width) {
            // Verifica se a bola passou pela altura da raquete da IA
            if (this.y + this.size < paddle2.y || this.y > paddle2.y + paddle2.height) {
                // Bola passou longe da raquete da IA - JOGADOR PONTUA
                this.reset(canvas);
                game.updateScore();
                return true;
            }
        }
        
        return true; // Jogo continua
    }

    createParticles(game) {
        for (let i = 0; i < CONFIG.PARTICLE.COUNT_ON_HIT; i++) {
            game.particles.push(new Particle(this.x, this.y, this.speedX, this.speedY));
        }
    }

    reset(canvas) {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.speedX = this.defaultSpeedX * (Math.random() > 0.5 ? 1 : -1);
        this.speedY = this.defaultSpeedY * (Math.random() > 0.5 ? 1 : -1);
        this.trail = [];
    }

    draw(ctx, theme) {
        const speed = Math.sqrt(this.speedX ** 2 + this.speedY ** 2);
        const hue = Math.min(360, speed * 20);
        
        // Desenha rastro
        this.trail.forEach((pos, index) => {
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, this.size / 2 * (1 - index / 15), 0, Math.PI * 2);
            ctx.fillStyle = theme === 'dark' 
                ? `hsla(${hue}, 100%, 70%, ${1 - index / 15})` 
                : `hsla(${hue}, 100%, 30%, ${1 - index / 15})`;
            ctx.fill();
            ctx.closePath();
        });
        
        // Desenha bola
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
        ctx.fillStyle = theme === 'dark' 
            ? `hsl(${hue}, 100%, 70%)` 
            : `hsl(${hue}, 100%, 30%)`;
        ctx.fill();
        ctx.closePath();
    }
}

/**
 * Classe principal do jogo Pong - Refatorada
 */
class Game {
    constructor() {
        this.initializeCanvas();
        this.initializeGameObjects();
        this.initializeGameState();
        this.initializeManagers();
        this.initializeUI();
        this.initializeControls();
        this.showIntro();
    }

    initializeCanvas() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
    }

    initializeGameObjects() {
        this.paddle1 = new Paddle(0, (this.canvas.height - CONFIG.PADDLE.HEIGHT) / 2);
        this.paddle2 = new Paddle(this.canvas.width - CONFIG.PADDLE.WIDTH, (this.canvas.height - CONFIG.PADDLE.HEIGHT) / 2, true);
        this.ball = new Ball(this.canvas.width / 2, this.canvas.height / 2);
        this.particles = [];
        this.backgroundStars = [];
        this.generateBackgroundStars();
    }

    initializeGameState() {
        this.score = 0;
        this.level = 1;
        this.highScore = StorageManager.get('highScore', 0);
        this.state = 'intro';
        this.difficulty = 'medium';
        this.theme = StorageManager.get('theme', 'dark');
        document.body.className = `${this.theme}-theme`;

        // Estat√≠sticas
        this.gameTime = 0;
        this.gameStartTime = 0;
        this.consecutiveHits = 0;
        this.totalGamesPlayed = StorageManager.get('totalGamesPlayed', 0);
        this.maxSpeed = 0;
        this.ballHits = 0;
        this.aiHits = 0;
        this.playerHits = 0;
        this.combo = 0;
        this.maxCombo = StorageManager.get('maxCombo', 0);
        this.comboTimer = 0;

        // Sistema de pause
        this.isPaused = false;
        this.pauseStartTime = 0;
        this.totalPauseTime = 0;

        // Controles
        this.upPressed = false;
        this.downPressed = false;
        this.lastTouchY = null;
        this.lastTapTime = 0;

        // Timers
        this.lastUpdate = 0;
        this.frameInterval = 1000 / CONFIG.FPS;

        // IA adaptativa
        this.adaptiveDifficulty = StorageManager.get('adaptiveDifficulty', true);
        this.performanceHistory = [];
    }

    initializeManagers() {
        this.audioManager = new AudioManager();
        this.achievementManager = new AchievementManager();
    }

    initializeUI() {
        this.scoreDisplay = document.getElementById('score');
        this.levelDisplay = document.getElementById('level');
        this.highScoreDisplay = document.getElementById('highScore');
        this.finalScoreDisplay = document.getElementById('finalScore');
        this.finalLevelDisplay = document.getElementById('finalLevel');
        this.gameIntro = document.getElementById('gameIntro');
        this.gameMenu = document.getElementById('gameMenu');
        this.gameOverScreen = document.getElementById('gameOver');
        this.notification = document.getElementById('notification');
        this.achievementsList = document.getElementById('achievementsList');

        this.highScoreDisplay.textContent = this.highScore;
        this.levelDisplay.textContent = this.level;
    }

    initializeControls() {
        document.addEventListener('keydown', (e) => this.handleKeyDown(e));
        document.addEventListener('keyup', (e) => this.handleKeyUp(e));
        this.canvas.addEventListener('touchmove', (e) => this.handleTouch(e), { passive: false });
        this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
    }

    // ================== M√âTODOS DE CONFIGURA√á√ÉO ==================

    generateBackgroundStars() {
        this.backgroundStars = [];
        for (let i = 0; i < 50; i++) {
            this.backgroundStars.push({
                x: Math.random() * this.canvas.width,
                y: Math.random() * this.canvas.height,
                size: Math.random() * 2 + 1,
                opacity: Math.random() * 0.5 + 0.3,
                twinkleSpeed: Math.random() * 0.02 + 0.01
            });
        }
    }

    toggleTheme() {
        this.theme = this.theme === 'dark' ? 'light' : 'dark';
        document.body.className = `${this.theme}-theme`;
        StorageManager.set('theme', this.theme);
    }

    setDifficulty(level) {
        this.difficulty = level;
        this.level = 1;
        this.updateDifficulty();
    }

    updateDifficulty() {
        const levelFactor = 1 + (this.level - 1) * CONFIG.LEVEL.DIFFICULTY_FACTOR;
        
        const difficultySettings = {
            easy: {
                speedX: 4 * levelFactor,
                speedY: 2 * levelFactor,
                aiSpeed: 6 * levelFactor,
                aiHeight: 120 / levelFactor
            },
            hard: {
                speedX: 7 * levelFactor,
                speedY: 5 * levelFactor,
                aiSpeed: 10 * levelFactor,
                aiHeight: 80 / levelFactor
            },
            medium: {
                speedX: 5 * levelFactor,
                speedY: 3 * levelFactor,
                aiSpeed: 8 * levelFactor,
                aiHeight: 100 / levelFactor
            }
        };

        const settings = difficultySettings[this.difficulty];
        this.ball.defaultSpeedX = settings.speedX;
        this.ball.defaultSpeedY = settings.speedY;
        this.paddle2.speed = settings.aiSpeed;
        this.paddle2.height = settings.aiHeight;
        
        this.ball.reset(this.canvas);
        this.paddle2.reset();
        this.levelDisplay.textContent = this.level;
    }

    // ================== M√âTODOS DE GAME STATE ==================

    togglePause() {
        if (this.state !== 'playing') return;
        
        this.isPaused = !this.isPaused;
        
        if (this.isPaused) {
            this.pauseStartTime = Date.now();
            this.showNotification('Jogo Pausado - Pressione P para continuar');
        } else {
            this.totalPauseTime += Date.now() - this.pauseStartTime;
            this.showNotification('Jogo Retomado');
            this.lastUpdate = performance.now();
            this.update();
        }
    }

    updateGameStats() {
        if (this.gameStartTime && !this.isPaused) {
            this.gameTime = Date.now() - this.gameStartTime - this.totalPauseTime;
        }
        
        const currentSpeed = Math.sqrt(this.ball.speedX ** 2 + this.ball.speedY ** 2);
        this.maxSpeed = Math.max(this.maxSpeed, currentSpeed);
        
        if (this.comboTimer > 0) {
            this.comboTimer--;
        } else if (this.combo > 0) {
            this.combo = 0;
        }
    }

    updateScore() {
        this.score++;
        this.consecutiveHits++;
        this.combo++;
        this.comboTimer = CONFIG.COMBO.RESET_TIME;
        
        if (this.combo > this.maxCombo) {
            this.maxCombo = this.combo;
            StorageManager.set('maxCombo', this.maxCombo);
        }
        
        this.scoreDisplay.textContent = this.score;
        this.audioManager.playSound('score');
        
        if (this.combo >= CONFIG.COMBO.MIN_FOR_NOTIFICATION) {
            this.audioManager.playSound('combo');
            this.showNotification(`Combo x${this.combo}!`);
        }
        
        if (this.score % CONFIG.LEVEL.POINTS_PER_LEVEL === 0) {
            this.level++;
            this.updateDifficulty();
            this.showNotification(`N√≠vel ${this.level}!`);
        }
        
        this.achievementManager.checkAchievements(this);
    }

    // ================== M√âTODOS DE CONTROLE ==================

    handleKeyDown(e) {
        switch(e.key) {
            case 'ArrowUp':
                this.upPressed = true;
                break;
            case 'ArrowDown':
                this.downPressed = true;
                break;
            case 'p':
            case 'P':
                this.togglePause();
                break;
            case 'Escape':
                if (this.state === 'playing') {
                    this.showMenu();
                }
                break;
            case 'm':
            case 'M':
                const soundEnabled = this.audioManager.toggle();
                this.showNotification(`Som ${soundEnabled ? 'Ativado' : 'Desativado'}`);
                break;
        }
    }

    handleKeyUp(e) {
        if (e.key === 'ArrowUp') this.upPressed = false;
        if (e.key === 'ArrowDown') this.downPressed = false;
    }

    handleTouch(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        const touchY = touch.clientY - rect.top;
        this.lastTouchY = touchY;
    }

    handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        const touchY = touch.clientY - rect.top;
        this.lastTouchY = touchY;
        
        if (this.lastTapTime && Date.now() - this.lastTapTime < 300) {
            this.togglePause();
        }
        this.lastTapTime = Date.now();
    }

    updatePlayerMovement() {
        if (this.upPressed) this.paddle1.moveUp();
        if (this.downPressed) this.paddle1.moveDown(this.canvas.height);
        
        if (this.lastTouchY !== null) {
            this.paddle1.y = Math.max(0, Math.min(
                this.lastTouchY - this.paddle1.height / 2, 
                this.canvas.height - this.paddle1.height
            ));
        }
    }

    // ================== M√âTODOS DE INTERFACE ==================

    showNotification(message) {
        this.notification.textContent = message;
        this.notification.style.display = 'block';
        setTimeout(() => {
            this.notification.style.display = 'none';
        }, 3000);
    }

    showIntro() {
        this.state = 'intro';
        this.gameIntro.style.display = 'block';
        this.gameMenu.style.display = 'none';
        this.gameOverScreen.style.display = 'none';
    }

    showMenu() {
        this.state = 'menu';
        this.gameIntro.style.display = 'none';
        this.gameMenu.style.display = 'block';
        this.gameOverScreen.style.display = 'none';
        
        this.updateMenuDisplay();
        this.achievementManager.updateDisplay(this.achievementsList);
    }

    updateMenuDisplay() {
        document.getElementById('totalGames').textContent = this.totalGamesPlayed;
        document.getElementById('maxComboDisplay').textContent = this.maxCombo;
        
        const soundButton = this.gameMenu.querySelector('button[onclick*="audioManager.enabled"]');
        if (soundButton) {
            soundButton.textContent = this.audioManager.enabled ? 'üîä Som: ON' : 'üîá Som: OFF';
        }
        
        const aiButton = this.gameMenu.querySelector('button[onclick*="adaptiveDifficulty"]');
        if (aiButton) {
            aiButton.textContent = this.adaptiveDifficulty ? 'ü§ñ IA Adaptativa: ON' : 'ü§ñ IA Adaptativa: OFF';
        }
    }

    showGameOver() {
        this.state = 'gameover';
        this.audioManager.playSound('gameover');
        
        this.updateGameOverDisplay();
        this.updateHighScore();
        this.achievementManager.checkAchievements(this);
    }

    updateGameOverDisplay() {
        this.finalScoreDisplay.textContent = this.score;
        this.finalLevelDisplay.textContent = this.level;
        document.getElementById('finalTime').textContent = Math.floor(this.gameTime / 1000);
        document.getElementById('finalCombo').textContent = this.maxCombo;
        document.getElementById('finalMaxSpeed').textContent = Math.floor(this.maxSpeed);
        
        this.gameOverScreen.style.display = 'block';
    }

    updateHighScore() {
        let newRecord = false;
        if (this.score > this.highScore) {
            this.highScore = this.score;
            StorageManager.set('highScore', this.highScore);
            this.highScoreDisplay.textContent = this.highScore;
            newRecord = true;
        }
        
        const recordNotification = document.getElementById('newRecordNotification');
        recordNotification.style.display = newRecord ? 'block' : 'none';
    }

    /**
     * Inicia uma nova partida
     */
    start() {
        this.state = 'playing';
        
        // Reseta vari√°veis do jogo
        this.score = 0;
        this.level = 1;
        this.consecutiveHits = 0;
        this.ballHits = 0;
        this.aiHits = 0;
        this.playerHits = 0;
        this.combo = 0;
        this.comboTimer = 0;
        this.maxSpeed = 0;
        this.isPaused = false;
        this.totalPauseTime = 0;
        this.gameStartTime = Date.now();
        
        // Incrementa total de jogos
        this.totalGamesPlayed++;
        StorageManager.set('totalGamesPlayed', this.totalGamesPlayed);
        
        // Atualiza displays
        this.scoreDisplay.textContent = this.score;
        this.levelDisplay.textContent = this.level;
        
        // Reseta elementos do jogo
        this.ball.reset(this.canvas);
        this.paddle1.reset();
        this.paddle2.reset();
        this.setDifficulty(this.difficulty);
        this.particles = [];
        
        // Esconde todas as telas de interface
        this.gameIntro.style.display = 'none';
        this.gameMenu.style.display = 'none';
        this.gameOverScreen.style.display = 'none';
        this.notification.style.display = 'none';
        
        // Inicia o loop de atualiza√ß√£o
        this.lastUpdate = performance.now();
        this.update();
    }

    /**
     * Desenha a interface HUD (heads-up display) do jogo
     */
    drawHUD() {
        // Desenha estrelas de fundo primeiro
        this.drawBackgroundStars();
        
        // Barra de progresso para o pr√≥ximo n√≠vel
        const pointsToNextLevel = 5 - (this.score % 5);
        const progress = (5 - pointsToNextLevel) / 5;
        
        // Fundo da barra de progresso
        this.ctx.fillStyle = this.theme === 'dark' ? '#555' : '#ccc';
        this.ctx.fillRect(10, 10, 100, 10);
        
        // Preenchimento da barra de progresso
        this.ctx.fillStyle = 'green';
        this.ctx.fillRect(10, 10, 100 * progress, 10);

        // Texto da barra de progresso
        this.ctx.fillStyle = this.theme === 'dark' ? '#fff' : '#000';
        this.ctx.font = '12px Arial';
        this.ctx.fillText(`N√≠vel ${this.level} (${pointsToNextLevel} para pr√≥ximo)`, 10, 35);

        // Display de combo
        if (this.combo > 1) {
            this.ctx.save();
            this.ctx.fillStyle = 'gold';
            this.ctx.font = 'bold 16px Arial';
            this.ctx.textAlign = 'center';
            const comboY = 80 + Math.sin(Date.now() * 0.01) * 5;
            this.ctx.fillText(`COMBO x${this.combo}!`, this.canvas.width / 2, comboY);
            this.ctx.restore();
        }

        // Estat√≠sticas do jogo (canto superior direito)
        this.ctx.save();
        this.ctx.fillStyle = this.theme === 'dark' ? '#fff' : '#000';
        this.ctx.font = '12px Arial';
        this.ctx.textAlign = 'right';
        
        const stats = [
            `Tempo: ${Math.floor(this.gameTime / 1000)}s`,
            `Velocidade: ${Math.floor(Math.sqrt(this.ball.speedX ** 2 + this.ball.speedY ** 2))}`,
            `Hits: ${this.ballHits}`,
            `Max Combo: ${this.maxCombo}`
        ];
        
        stats.forEach((stat, index) => {
            this.ctx.fillText(stat, this.canvas.width - 10, 15 + index * 15);
        });
        
        this.ctx.restore();

        // Indicador de pause
        if (this.isPaused) {
            this.ctx.save();
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            
            this.ctx.fillStyle = '#fff';
            this.ctx.font = 'bold 48px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('PAUSADO', this.canvas.width / 2, this.canvas.height / 2);
            
            this.ctx.font = '16px Arial';
            this.ctx.fillText('Pressione P para continuar', this.canvas.width / 2, this.canvas.height / 2 + 40);
            this.ctx.restore();
        }
    }

    /**
     * Loop principal de atualiza√ß√£o do jogo
     * @param {number} timestamp - Timestamp atual para controle de FPS
     */
    update(timestamp) {
        if (this.state !== 'playing' || this.isPaused) {
            if (this.state === 'playing' && this.isPaused) {
                // Continue o loop mesmo pausado para manter o HUD
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawHUD();
                requestAnimationFrame((ts) => this.update(ts));
            }
            return;
        }
        
        // Controle de FPS
        if (timestamp - this.lastUpdate < this.frameInterval) {
            requestAnimationFrame((ts) => this.update(ts));
            return;
        }
        this.lastUpdate = timestamp;

        // Atualiza estat√≠sticas do jogo
        this.updateGameStats();

        // Atualiza IA da raquete 2 com dificuldade adaptativa
        if (this.adaptiveDifficulty) {
            this.updateAdaptiveAI();
        }
        this.paddle2.moveAI(this.ball.y, this.canvas.height);

        // Controles do jogador
        if (this.upPressed) this.paddle1.moveUp();
        if (this.downPressed) this.paddle1.moveDown(this.canvas.height);
        
        // Controle por toque (mobile)
        if (this.lastTouchY !== null) {
            this.paddle1.y = Math.max(0, Math.min(
                this.lastTouchY - this.paddle1.height / 2, 
                this.canvas.height - this.paddle1.height
            ));
        }

        // Atualiza part√≠culas e remove as mortas
        this.particles = this.particles.filter(particle => particle.update());

        // Atualiza a bola e verifica fim de jogo
        if (!this.ball.update(this.canvas, this.paddle1, this.paddle2, () => this.updateScore(), this)) {
            this.consecutiveHits = 0; // Reset na derrota
            this.showGameOver();
            return;
        }

        // Renderiza√ß√£o
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Desenha elementos do jogo
        this.particles.forEach(particle => particle.draw(this.ctx, this.theme));
        this.paddle1.draw(this.ctx, this.theme);
        this.paddle2.draw(this.ctx, this.theme);
        this.ball.draw(this.ctx, this.theme);
        this.drawHUD();

        // Continua o loop de atualiza√ß√£o
        requestAnimationFrame((ts) => this.update(ts));
    }

    /**
     * Sistema de IA adaptativa baseado na performance do jogador
     */
    updateAdaptiveAI() {
        // Adiciona performance atual ao hist√≥rico
        this.performanceHistory.push({
            score: this.score,
            time: this.gameTime,
            level: this.level
        });

        // Mant√©m apenas os √∫ltimos 10 registros
        if (this.performanceHistory.length > 10) {
            this.performanceHistory.shift();
        }

        // Ajusta dificuldade baseado na performance
        if (this.performanceHistory.length >= 3) {
            const avgScore = this.performanceHistory.reduce((sum, p) => sum + p.score, 0) / this.performanceHistory.length;
            
            if (avgScore > this.level * 3) {
                // Jogador indo muito bem, aumenta dificuldade
                this.paddle2.speed = Math.min(this.paddle2.speed * 1.02, 15);
            } else if (avgScore < this.level) {
                // Jogador com dificuldade, reduz um pouco
                this.paddle2.speed = Math.max(this.paddle2.speed * 0.98, 3);
            }
        }
    }

    drawBackgroundStars() {
        this.backgroundStars.forEach(star => {
            star.opacity += Math.sin(Date.now() * star.twinkleSpeed) * 0.01;
            star.opacity = Math.max(0.2, Math.min(0.8, star.opacity));
            
            this.ctx.save();
            this.ctx.globalAlpha = star.opacity;
            this.ctx.fillStyle = this.theme === 'dark' ? '#ffffff' : '#cccccc';
            this.ctx.beginPath();
            this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
        });
    }
}

// Inicializa o jogo quando a p√°gina carrega
const game = new Game();
</script>
</body>
</html>